using System;
using System.Net.Sockets;
using System.Text;
using UnityEngine;
using System.Threading;
using System.Collections.Generic;

public class LiDARDetectTest : MonoBehaviour
{
    [Header("LiDAR Settings")]
    public string lidarIP = "192.168.0.10";
    public int lidarPort = 10940;
    
    [Header("Visualization Settings")]
    public float visualScale = 0.01f;
    public float maxDistance = 5000f;
    public Color scanLineColor = Color.green;
    public Color touchIndicatorColor = Color.red;
    public float lineWidth = 0.05f;
    
    [Header("Touch Detection Settings")]
    [Tooltip("„Åì„ÅÆÂÄ§„Çà„ÇäË∑ùÈõ¢„ÅåÁü≠„Åè„Å™„Å£„Åü„ÇâÊ§úÂá∫ÔºàmmÔºâ")]
    public float touchThreshold = 20f; // 20mm = 2cm
    public float touchCooldown = 0.3f;
    public float autoCalibrationDelay = 5f;
    
    [Header("Camera Settings")]
    public bool autoSetupCamera = true;
    public float cameraHeight = 50f;
    public float cameraSize = 25f;
    
    [Header("Manual Calibration")]
    public bool calibrateNow = false;
    
    [Header("Debug")]
    public bool showDebugInfo = true;
    
    // ÈÄö‰ø°
    private TcpClient client;
    private NetworkStream stream;
    private Thread receiveThread;
    private bool isRunning = false;
    
    // „Éá„Éº„Çø
    private Queue<string> dataQueue = new Queue<string>();
    private object queueLock = new object();
    private List<int> currentDistances = new List<int>();
    private List<int> baselineDistances = new List<int>();
    private bool isCalibrated = false;
    private Dictionary<int, float> lastTouchTime = new Dictionary<int, float>();
    
    // ÂèØË¶ñÂåñ
    private LineRenderer scanLineRenderer;
    private GameObject sensorPosition;
    
    // „Éá„Éê„ÉÉ„Ç∞
    private int touchDetectionCount = 0;
    private float lastDebugTime = 0f;
    
    void Start()
    {
        Debug.Log("=== LiDAR Â£Å„Çø„ÉÉ„ÉÅÊ§úÂá∫„Ç∑„Çπ„ÉÜ„É† Ëµ∑Âãï ===");
        Debug.Log($"Ê§úÂá∫ÈñæÂÄ§: {touchThreshold}mmÔºà{touchThreshold/10f}cmÔºâ");
        
        SetupCamera();
        SetupVisualization();
        ConnectToLiDAR();
        StartCoroutine(AutoCalibrationSequence());
    }
    
    void SetupCamera()
    {
        if (!autoSetupCamera) return;
        
        Camera mainCamera = Camera.main;
        if (mainCamera == null) return;
        
        mainCamera.transform.position = new Vector3(0, cameraHeight, 0);
        mainCamera.transform.rotation = Quaternion.Euler(90f, 0, 0);
        mainCamera.orthographic = true;
        mainCamera.orthographicSize = cameraSize;
        mainCamera.backgroundColor = new Color(0.05f, 0.05f, 0.1f);
    }
    
    void SetupVisualization()
    {
        scanLineRenderer = gameObject.AddComponent<LineRenderer>();
        scanLineRenderer.material = new Material(Shader.Find("Sprites/Default"));
        scanLineRenderer.startColor = scanLineColor;
        scanLineRenderer.endColor = scanLineColor;
        scanLineRenderer.startWidth = lineWidth;
        scanLineRenderer.endWidth = lineWidth;
        scanLineRenderer.useWorldSpace = true;
        scanLineRenderer.positionCount = 0;
        
        sensorPosition = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        sensorPosition.transform.position = Vector3.zero;
        sensorPosition.transform.localScale = Vector3.one * 0.5f;
        sensorPosition.name = "LiDAR Sensor";
        
        Renderer renderer = sensorPosition.GetComponent<Renderer>();
        renderer.material = new Material(Shader.Find("Sprites/Default"));
        renderer.material.color = Color.yellow;
    }
    
    void ConnectToLiDAR()
    {
        try
        {
            Debug.Log($"[Êé•Á∂ö] {lidarIP}:{lidarPort}");
            
            client = new TcpClient();
            client.Connect(lidarIP, lidarPort);
            stream = client.GetStream();
            stream.ReadTimeout = 5000;
            stream.WriteTimeout = 5000;
            
            SendCommand("SCIP2.0\n");
            Thread.Sleep(300);
            SendCommand("BM\n");
            Thread.Sleep(300);
            SendCommand("MD0000072500000\n");
            Thread.Sleep(300);
            
            isRunning = true;
            receiveThread = new Thread(ReceiveDataThread);
            receiveThread.IsBackground = true;
            receiveThread.Start();
            
            Debug.Log("[Êé•Á∂ö] ÂÆå‰∫Ü");
        }
        catch (Exception e)
        {
            Debug.LogError($"[Êé•Á∂ö„Ç®„É©„Éº] {e.Message}");
        }
    }
    
    System.Collections.IEnumerator AutoCalibrationSequence()
    {
        Debug.Log($"[„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥] {autoCalibrationDelay}ÁßíÂæå„Å´ÈñãÂßã");
        Debug.Log("‚ö†Ô∏è  Â£Å„Å®„Çª„É≥„Çµ„Éº„ÅÆÈñì„Å´‰Ωï„ÇÇÂÖ•„Çå„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ");
        
        float elapsed = 0f;
        while (currentDistances.Count == 0 && elapsed < 15f)
        {
            yield return new WaitForSeconds(1f);
            elapsed += 1f;
        }
        
        if (currentDistances.Count == 0)
        {
            Debug.LogError("[„Ç®„É©„Éº] „Éá„Éº„ÇøÂèñÂæóÂ§±Êïó");
            yield break;
        }
        
        float remaining = autoCalibrationDelay - elapsed;
        if (remaining > 0) yield return new WaitForSeconds(remaining);
        
        PerformCalibration();
    }
    
    void PerformCalibration()
    {
        lock (queueLock)
        {
            if (currentDistances.Count == 0)
            {
                Debug.LogWarning("[„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥] „Éá„Éº„Çø„Å™„Åó");
                return;
            }
            
            baselineDistances = new List<int>(currentDistances);
            isCalibrated = true;
            
            // Áµ±Ë®à
            int validCount = 0;
            float avgDist = 0f;
            float minDist = float.MaxValue;
            float maxDist = 0f;
            
            foreach (int dist in baselineDistances)
            {
                if (dist > 0 && dist < maxDistance)
                {
                    validCount++;
                    avgDist += dist;
                    if (dist < minDist) minDist = dist;
                    if (dist > maxDist) maxDist = dist;
                }
            }
            
            if (validCount > 0) avgDist /= validCount;
            
            Debug.Log("========================================");
            Debug.Log("‚úÖ „Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥ÂÆå‰∫Ü");
            Debug.Log($"Ê∏¨ÂÆöÁÇπÊï∞: {baselineDistances.Count}");
            Debug.Log($"ÊúâÂäπÁÇπÊï∞: {validCount}");
            Debug.Log($"ÊúÄÂ∞èË∑ùÈõ¢: {minDist:F0}mmÔºà{minDist/1000f:F2}mÔºâ");
            Debug.Log($"ÊúÄÂ§ßË∑ùÈõ¢: {maxDist:F0}mmÔºà{maxDist/1000f:F2}mÔºâ");
            Debug.Log($"Âπ≥ÂùáË∑ùÈõ¢: {avgDist:F0}mmÔºà{avgDist/1000f:F2}mÔºâ");
            Debug.Log($"Ê§úÂá∫ÈñæÂÄ§: {touchThreshold}mmÔºà{touchThreshold/10f}cmÔºâ");
            Debug.Log("========================================");
        }
    }
    
    void Update()
    {
        if (calibrateNow)
        {
            calibrateNow = false;
            PerformCalibration();
        }
        
        ProcessReceivedData();
        
        if (currentDistances.Count > 0)
        {
            VisualizeScanning();
            if (isCalibrated) DetectTouches();
        }
        
        // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±Ë°®Á§∫Ôºà5Áßí„Åî„Å®Ôºâ
        if (showDebugInfo && Time.time - lastDebugTime > 5f)
        {
            lastDebugTime = Time.time;
            ShowDebugInfo();
        }
    }
    
    void ShowDebugInfo()
    {
        if (!isCalibrated || currentDistances.Count == 0) return;
        
        // ÊúÄÂ§ß„ÅÆÂ∑ÆÂàÜ„ÇíË¶ã„Å§„Åë„Çã
        float maxDiff = 0f;
        int maxDiffIndex = -1;
        
        for (int i = 0; i < currentDistances.Count; i++)
        {
            if (i >= baselineDistances.Count) break;
            
            int currentDist = currentDistances[i];
            int baseDist = baselineDistances[i];
            
            if (currentDist <= 0 || baseDist <= 0) continue;
            
            float diff = baseDist - currentDist;
            if (diff > maxDiff)
            {
                maxDiff = diff;
                maxDiffIndex = i;
            }
        }
        
        if (maxDiffIndex >= 0)
        {
            Debug.Log($"[„É¢„Éã„Çø„É™„É≥„Ç∞] ÊúÄÂ§ßÂ∑ÆÂàÜ: {maxDiff:F0}mmÔºàÁÇπ{maxDiffIndex}Ôºâ| ÈñæÂÄ§: {touchThreshold}mm");
        }
    }
    
    void ProcessReceivedData()
    {
        lock (queueLock)
        {
            while (dataQueue.Count > 0)
            {
                ParseLiDARData(dataQueue.Dequeue());
            }
        }
    }
    
    void ParseLiDARData(string line)
    {
        if (line.StartsWith("MD") || line.Length <= 5 || 
            (line.Length < 20 && char.IsUpper(line[0]))) return;
        
        if (line.Length > 50)
        {
            lock (queueLock)
            {
                currentDistances = DecodeSCIP2Data(line);
            }
        }
    }
    
    List<int> DecodeSCIP2Data(string encodedData)
    {
        List<int> distances = new List<int>();
        
        for (int i = 0; i <= encodedData.Length - 3; i += 3)
        {
            try
            {
                int val = ((encodedData[i] - 0x30) << 12) | 
                          ((encodedData[i + 1] - 0x30) << 6) | 
                          (encodedData[i + 2] - 0x30);
                distances.Add(val);
            }
            catch { break; }
        }
        
        return distances;
    }
    
    void VisualizeScanning()
    {
        List<int> distances;
        lock (queueLock)
        {
            distances = new List<int>(currentDistances);
        }
        
        if (distances.Count == 0) return;
        
        scanLineRenderer.positionCount = distances.Count + 1;
        
        float angleRange = 270f;
        float angleStep = angleRange / (distances.Count - 1);
        float startAngle = -135f;
        
        for (int i = 0; i < distances.Count; i++)
        {
            float distance = (distances[i] <= 0 || distances[i] > maxDistance) 
                ? maxDistance : distances[i];
            
            float angle = (startAngle + angleStep * i) * Mathf.Deg2Rad;
            float x = distance * Mathf.Cos(angle) * visualScale;
            float z = distance * Mathf.Sin(angle) * visualScale;
            
            scanLineRenderer.SetPosition(i, new Vector3(x, 0, z));
        }
        
        scanLineRenderer.SetPosition(distances.Count, scanLineRenderer.GetPosition(0));
    }
    
    void DetectTouches()
    {
        if (baselineDistances.Count != currentDistances.Count) return;
        
        float currentTime = Time.time;
        
        for (int i = 0; i < currentDistances.Count; i++)
        {
            int currentDist = currentDistances[i];
            int baseDist = baselineDistances[i];
            
            // ÁÑ°Âäπ„Å™„Éá„Éº„Çø„ÅÆ„Åø„Çπ„Ç≠„ÉÉ„ÉóÔºàÁØÑÂõ≤„ÉÅ„Çß„ÉÉ„ÇØ„Å™„ÅóÔºâ
            if (currentDist <= 0 || baseDist <= 0) continue;
            
            float distanceDiff = baseDist - currentDist;
            
            if (distanceDiff > touchThreshold)
            {
                if (!lastTouchTime.ContainsKey(i) || 
                    (currentTime - lastTouchTime[i]) > touchCooldown)
                {
                    lastTouchTime[i] = currentTime;
                    OnWallTouched(CalculateTouchPosition(i, currentDist), i, distanceDiff, currentDist, baseDist);
                }
            }
        }
    }
    
    Vector3 CalculateTouchPosition(int index, int distance)
    {
        float angleRange = 270f;
        float angleStep = angleRange / (currentDistances.Count - 1);
        float startAngle = -135f;
        float angle = (startAngle + angleStep * index) * Mathf.Deg2Rad;
        
        float x = distance * Mathf.Cos(angle) * visualScale;
        float z = distance * Mathf.Sin(angle) * visualScale;
        
        return new Vector3(x, 0, z);
    }
    
    void OnWallTouched(Vector3 position, int sensorIndex, float distanceDiff, int currentDist, int baseDist)
    {
        touchDetectionCount++;
        
        Debug.Log($"üéÜ „Çø„ÉÉ„ÉÅ #{touchDetectionCount}");
        Debug.Log($"   ‰ΩçÁΩÆ: ({position.x:F1}, {position.z:F1})");
        Debug.Log($"   ÁÇπÁï™Âè∑: {sensorIndex}");
        Debug.Log($"   Âü∫Ê∫ñË∑ùÈõ¢: {baseDist}mmÔºà{baseDist/1000f:F2}mÔºâ");
        Debug.Log($"   ÁèæÂú®Ë∑ùÈõ¢: {currentDist}mmÔºà{currentDist/1000f:F2}mÔºâ");
        Debug.Log($"   Â∑ÆÂàÜ: {distanceDiff:F0}mmÔºà{distanceDiff/10f:F1}cmÔºâ");
        
        CreateTouchEffect(position);
    }
    
    void CreateTouchEffect(Vector3 position)
    {
        GameObject effect = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        effect.transform.position = position;
        effect.transform.localScale = Vector3.one * 2f;
        effect.name = "Touch Effect";
        
        Renderer renderer = effect.GetComponent<Renderer>();
        renderer.material = new Material(Shader.Find("Sprites/Default"));
        renderer.material.color = touchIndicatorColor;
        
        Destroy(effect, 2f);
        
        // „Åì„Åì„Å´Ëä±ÁÅ´„Ç®„Éï„Çß„ÇØ„Éà„ÇíËøΩÂä†
    }
    
    void ReceiveDataThread()
    {
        byte[] buffer = new byte[8192];
        StringBuilder messageBuilder = new StringBuilder();
        
        while (isRunning)
        {
            try
            {
                if (stream != null && stream.DataAvailable)
                {
                    int bytesRead = stream.Read(buffer, 0, buffer.Length);
                    string chunk = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    messageBuilder.Append(chunk);
                    
                    string fullMessage = messageBuilder.ToString();
                    string[] lines = fullMessage.Split(new[] { '\n', '\r' }, 
                        StringSplitOptions.RemoveEmptyEntries);
                    
                    if (!fullMessage.EndsWith("\n"))
                    {
                        messageBuilder.Clear();
                        messageBuilder.Append(lines[lines.Length - 1]);
                        Array.Resize(ref lines, lines.Length - 1);
                    }
                    else
                    {
                        messageBuilder.Clear();
                    }
                    
                    foreach (string line in lines)
                    {
                        if (!string.IsNullOrWhiteSpace(line))
                        {
                            lock (queueLock)
                            {
                                dataQueue.Enqueue(line.Trim());
                            }
                        }
                    }
                }
                Thread.Sleep(1);
            }
            catch (Exception e)
            {
                if (isRunning) Debug.LogError($"[Âèó‰ø°„Ç®„É©„Éº] {e.Message}");
            }
        }
    }
    
    void SendCommand(string command)
    {
        try
        {
            byte[] data = Encoding.ASCII.GetBytes(command);
            stream.Write(data, 0, data.Length);
            stream.Flush();
        }
        catch (Exception e)
        {
            Debug.LogError($"[ÈÄÅ‰ø°„Ç®„É©„Éº] {e.Message}");
        }
    }
    
    void OnApplicationQuit()
    {
        isRunning = false;
        
        if (receiveThread != null && receiveThread.IsAlive)
            receiveThread.Join(1000);
        
        if (stream != null)
        {
            try
            {
                SendCommand("QT\n");
                Thread.Sleep(100);
                stream.Close();
            }
            catch { }
        }
        
        if (client != null)
        {
            try { client.Close(); }
            catch { }
        }
    }
}
