using System;
using System.Net.Sockets;
using System.Text;
using UnityEngine;
using System.Threading;
using System.Collections.Generic;
using System.Linq;

public class LiDARTest : MonoBehaviour
{
    [Header("LiDAR Connection")]
    public string lidarIP = "192.168.0.10";
    public int lidarPort = 10940;
    
    [Header("Touch Detection")]
    [Tooltip("ã‚¿ãƒƒãƒæ¤œå‡ºã®è·é›¢é–¾å€¤ï¼ˆmmï¼‰")]
    public float touchThreshold = 30f;
    [Tooltip("é€£ç¶šæ¤œå‡ºã®ãŸã‚ã®ãƒ•ãƒ¬ãƒ¼ãƒ æ•°")]
    public int consistentFramesRequired = 3;
    [Tooltip("ã‚¿ãƒƒãƒé ˜åŸŸã®æœ€å°ã‚µã‚¤ã‚ºï¼ˆéš£æ¥ç‚¹æ•°ï¼‰")]
    public int minTouchAreaSize = 2;
    [Tooltip("ã‚¿ãƒƒãƒé–“ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“ï¼ˆç§’ï¼‰")]
    public float touchCooldown = 0.2f;
    [Tooltip("ãƒã‚¤ã‚ºãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã®å¼·åº¦")]
    public float noiseFilterStrength = 5f;
    
    [Header("Spatial Filtering")]
    [Tooltip("ç©ºé–“ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º")]
    public int spatialFilterWindow = 3;
    [Tooltip("æ™‚é–“ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã®å¼·åº¦")]
    public float temporalFilterAlpha = 0.7f;
    
    [Header("Visualization")]
    public float visualScale = 0.01f;
    public float maxDistance = 5000f;
    public Color scanLineColor = Color.green;
    public Color touchIndicatorColor = Color.red;
    public float lineWidth = 0.05f;
    
    [Header("Camera Setup")]
    public bool autoSetupCamera = true;
    public float cameraHeight = 50f;
    public float cameraSize = 25f;
    
    [Header("Debug")]
    public bool showDebugInfo = true;
    public bool showTouchVisualization = true;
    
    // ========== ğŸ† èŠ±ç«è¨­å®šï¼ˆæ–°è¦è¿½åŠ ï¼‰==========
    [Header("Fireworks")]
    [Tooltip("èŠ±ç«ãƒ—ãƒ¬ãƒãƒ–ï¼ˆParticleSystemä»˜ãï¼‰- æœªè¨­å®šã§ã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèŠ±ç«ãŒå‡ºã¾ã™")]
    public GameObject fireworksPrefab;
    [Tooltip("èŠ±ç«ã®è‰²ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³")]
    public Color[] fireworksColors = new Color[] 
    {
        Color.red, Color.blue, Color.yellow, Color.magenta, Color.cyan, Color.green
    };
    [Tooltip("èŠ±ç«ã®ã‚¹ã‚±ãƒ¼ãƒ«")]
    public float fireworksScale = 2f;
    [Tooltip("èŠ±ç«ã®æŒç¶šæ™‚é–“ï¼ˆç§’ï¼‰")]
    public float fireworksDuration = 3f;
    [Tooltip("èŠ±ç«ã®é«˜ã•ã‚ªãƒ•ã‚»ãƒƒãƒˆ")]
    public float fireworksHeightOffset = 2f;
    [Tooltip("éŸ³å£°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰")]
    public AudioClip fireworksSound;
    // =========================================
    
    // é€šä¿¡é–¢é€£
    private TcpClient client;
    private NetworkStream stream;
    private Thread receiveThread;
    private bool isRunning = false;
    
    // ãƒ‡ãƒ¼ã‚¿ç®¡ç†
    private Queue<string> dataQueue = new Queue<string>();
    private object queueLock = new object();
    
    // è·é›¢ãƒ‡ãƒ¼ã‚¿
    private List<float> currentDistances = new List<float>();
    private List<float> baselineDistances = new List<float>();
    private List<float> filteredDistances = new List<float>();
    private List<float> previousDistances = new List<float>();
    
    // ã‚¿ãƒƒãƒæ¤œå‡º
    private int[,] consistentTouchFrames;
    private Dictionary<int, TouchInfo> activeTouches = new Dictionary<int, TouchInfo>();
    private Dictionary<int, float> lastTouchTime = new Dictionary<int, float>();
    private bool isCalibrated = false;
    
    // å¯è¦–åŒ–
    private LineRenderer scanLineRenderer;
    private GameObject sensorPosition;
    private List<GameObject> touchEffects = new List<GameObject>();
    
    // ğŸ† èŠ±ç«ç®¡ç†ï¼ˆæ–°è¦è¿½åŠ ï¼‰
    private List<GameObject> activeFireworks = new List<GameObject>();
    private AudioSource audioSource;
    
    // çµ±è¨ˆ
    private int totalDetections = 0;
    private int validDetections = 0;
    private float lastDebugTime = 0f;
    
    [System.Serializable]
    public class TouchInfo
    {
        public Vector3 position;
        public float intensity;
        public int startIndex;
        public int endIndex;
        public float timestamp;
        
        public TouchInfo(Vector3 pos, float intens, int start, int end)
        {
            position = pos;
            intensity = intens;
            startIndex = start;
            endIndex = end;
            timestamp = Time.time;
        }
    }
    
    void Start()
    {
        Debug.Log("=== æ”¹è‰¯ç‰ˆ LiDAR ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ  ===");
        
        SetupCamera();
        SetupVisualization();
        SetupAudio(); // ğŸ† æ–°è¦è¿½åŠ 
        ConnectToLiDAR();
        
        // ä¸€å®šæ™‚é–“å¾Œã«è‡ªå‹•ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        Invoke(nameof(PerformCalibration), 3f);
    }
    
    // ğŸ† ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆæ–°è¦è¿½åŠ ï¼‰
    void SetupAudio()
    {
        audioSource = gameObject.AddComponent<AudioSource>();
        audioSource.playOnAwake = false;
        audioSource.spatialBlend = 0f; // 2D sound
    }
    
    void SetupCamera()
    {
        if (!autoSetupCamera) return;
        
        Camera mainCamera = Camera.main;
        if (mainCamera == null) return;
        
        mainCamera.transform.position = new Vector3(0, cameraHeight, 0);
        mainCamera.transform.rotation = Quaternion.Euler(90f, 0, 0);
        mainCamera.orthographic = true;
        mainCamera.orthographicSize = cameraSize;
        mainCamera.backgroundColor = new Color(0.05f, 0.05f, 0.1f);
    }
    
    void SetupVisualization()
    {
        // ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³
        scanLineRenderer = gameObject.AddComponent<LineRenderer>();
        scanLineRenderer.material = new Material(Shader.Find("Sprites/Default"));
        scanLineRenderer.startColor = scanLineColor;
        scanLineRenderer.endColor = scanLineColor;
        scanLineRenderer.startWidth = lineWidth;
        scanLineRenderer.endWidth = lineWidth;
        scanLineRenderer.useWorldSpace = true;
        scanLineRenderer.positionCount = 0;
        
        // ã‚»ãƒ³ã‚µãƒ¼ä½ç½®
        sensorPosition = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        sensorPosition.transform.position = Vector3.zero;
        sensorPosition.transform.localScale = Vector3.one * 0.5f;
        sensorPosition.name = "LiDAR Sensor";
        
        Renderer renderer = sensorPosition.GetComponent<Renderer>();
        renderer.material = new Material(Shader.Find("Sprites/Default"));
        renderer.material.color = Color.yellow;
    }
    
    void ConnectToLiDAR()
    {
        try
        {
            Debug.Log($"LiDARã«æ¥ç¶šä¸­: {lidarIP}:{lidarPort}");
            
            client = new TcpClient();
            client.Connect(lidarIP, lidarPort);
            stream = client.GetStream();
            stream.ReadTimeout = 5000;
            stream.WriteTimeout = 5000;
            
            // UST-20LXç”¨ã®ã‚³ãƒãƒ³ãƒ‰é€ä¿¡
            SendCommand("SCIP2.0\n");
            Thread.Sleep(200);
            SendCommand("BM\n");
            Thread.Sleep(200);
            SendCommand("MD0000072500000\n"); // é€£ç¶šæ¸¬å®šé–‹å§‹
            Thread.Sleep(200);
            
            isRunning = true;
            receiveThread = new Thread(ReceiveDataThread);
            receiveThread.IsBackground = true;
            receiveThread.Start();
            
            Debug.Log("LiDARæ¥ç¶šå®Œäº†");
        }
        catch (Exception e)
        {
            Debug.LogError($"LiDARæ¥ç¶šã‚¨ãƒ©ãƒ¼: {e.Message}");
        }
    }
    
    void PerformCalibration()
    {
        lock (queueLock)
        {
            if (currentDistances.Count == 0)
            {
                Debug.LogWarning("ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™");
                Invoke(nameof(PerformCalibration), 2f); // 2ç§’å¾Œã«å†è©¦è¡Œ
                return;
            }
            
            // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è·é›¢ã‚’è¨­å®šï¼ˆãƒã‚¤ã‚ºãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°é©ç”¨ï¼‰
            baselineDistances = new List<float>(ApplySpatialFilter(currentDistances));
            filteredDistances = new List<float>(baselineDistances);
            previousDistances = new List<float>(baselineDistances);
            
            // ä¸€è²«æ€§ãƒã‚§ãƒƒã‚¯ç”¨é…åˆ—ã‚’åˆæœŸåŒ–
            consistentTouchFrames = new int[baselineDistances.Count, consistentFramesRequired];
            
            isCalibrated = true;
            
            // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çµ±è¨ˆ
            var validDistances = baselineDistances.Where(d => d > 0 && d < maxDistance).ToList();
            if (validDistances.Any())
            {
                float avgDist = validDistances.Average();
                float minDist = validDistances.Min();
                float maxDist = validDistances.Max();
                
                Debug.Log("========== ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº† ==========");
                Debug.Log($"æ¸¬å®šç‚¹æ•°: {baselineDistances.Count}");
                Debug.Log($"æœ‰åŠ¹æ¸¬å®šç‚¹: {validDistances.Count}");
                Debug.Log($"è·é›¢ç¯„å›²: {minDist:F0}-{maxDist:F0}mm");
                Debug.Log($"å¹³å‡è·é›¢: {avgDist:F0}mm");
                Debug.Log($"æ¤œå‡ºé–¾å€¤: {touchThreshold}mm");
                Debug.Log("=========================================");
            }
        }
    }
    
    void Update()
    {
        ProcessReceivedData();
        
        if (currentDistances.Count > 0)
        {
            ApplyFiltering();
            VisualizeScanning();
            
            if (isCalibrated)
            {
                DetectTouches();
            }
        }
        
        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ï¼ˆ3ç§’ã”ã¨ï¼‰
        if (showDebugInfo && Time.time - lastDebugTime > 3f)
        {
            ShowDebugInfo();
            lastDebugTime = Time.time;
        }
        
        // å¤ã„ã‚¿ãƒƒãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        CleanupOldEffects();
    }
    
    void ApplyFiltering()
    {
        if (currentDistances.Count == 0) return;
        
        // ç©ºé–“ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆè¿‘éš£ç‚¹ã®å¹³æ»‘åŒ–ï¼‰
        var spatialFiltered = ApplySpatialFilter(currentDistances);
        
        // æ™‚é–“ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆæŒ‡æ•°ç§»å‹•å¹³å‡ï¼‰
        if (filteredDistances.Count == spatialFiltered.Count)
        {
            for (int i = 0; i < spatialFiltered.Count; i++)
            {
                filteredDistances[i] = temporalFilterAlpha * filteredDistances[i] + 
                                     (1 - temporalFilterAlpha) * spatialFiltered[i];
            }
        }
        else
        {
            filteredDistances = new List<float>(spatialFiltered);
        }
        
        // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ã®å·®åˆ†ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆæ€¥æ¿€ãªå¤‰åŒ–ã‚’æ¤œå‡ºï¼‰
        previousDistances = new List<float>(filteredDistances);
    }
    
    List<float> ApplySpatialFilter(List<float> distances)
    {
        var filtered = new List<float>(distances);
        int halfWindow = spatialFilterWindow / 2;
        
        for (int i = halfWindow; i < distances.Count - halfWindow; i++)
        {
            var windowValues = new List<float>();
            
            for (int j = i - halfWindow; j <= i + halfWindow; j++)
            {
                if (j >= 0 && j < distances.Count && distances[j] > 0)
                {
                    windowValues.Add(distances[j]);
                }
            }
            
            if (windowValues.Count >= 2)
            {
                // ä¸­å¤®å€¤ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆå¤–ã‚Œå€¤ã«å¼·ã„ï¼‰
                windowValues.Sort();
                filtered[i] = windowValues[windowValues.Count / 2];
            }
        }
        
        return filtered;
    }
    
    void DetectTouches()
    {
        if (baselineDistances.Count != filteredDistances.Count) return;
        
        var currentTouches = new List<TouchInfo>();
        var touchCandidates = new List<int>();
        
        // Step 1: ã‚¿ãƒƒãƒå€™è£œç‚¹ã‚’æ¤œå‡º
        for (int i = 0; i < filteredDistances.Count; i++)
        {
            float currentDist = filteredDistances[i];
            float baseDist = baselineDistances[i];
            
            if (currentDist <= 0 || baseDist <= 0) continue;
            
            float distanceDiff = baseDist - currentDist;
            
            // åŸºæœ¬çš„ãªé–¾å€¤ãƒã‚§ãƒƒã‚¯
            if (distanceDiff > touchThreshold)
            {
                // ãƒã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆå‘¨å›²ã®ç‚¹ã‚‚ä¼¼ãŸã‚ˆã†ãªå¤‰åŒ–ãŒã‚ã‚‹ã‹ï¼‰
                if (IsValidTouch(i, distanceDiff))
                {
                    touchCandidates.Add(i);
                }
            }
        }
        
        // Step 2: å€™è£œç‚¹ã‚’ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ï¼ˆéš£æ¥ç‚¹ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰
        var touchClusters = ClusterTouchPoints(touchCandidates);
        
        // Step 3: å„ã‚¯ãƒ©ã‚¹ã‚¿ãŒæœ‰åŠ¹ãªã‚¿ãƒƒãƒã‹ãƒã‚§ãƒƒã‚¯
        foreach (var cluster in touchClusters)
        {
            if (cluster.Count >= minTouchAreaSize)
            {
                // ä¸€è²«æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆè¤‡æ•°ãƒ•ãƒ¬ãƒ¼ãƒ ã§æ¤œå‡ºã•ã‚Œã¦ã„ã‚‹ã‹ï¼‰
                bool isConsistent = CheckTouchConsistency(cluster);
                
                if (isConsistent)
                {
                    var touchInfo = CreateTouchInfo(cluster);
                    currentTouches.Add(touchInfo);
                }
            }
        }
        
        // Step 4: æ–°ã—ã„ã‚¿ãƒƒãƒã®ã¿å‡¦ç†ï¼ˆã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³é©ç”¨ï¼‰
        ProcessValidTouches(currentTouches);
    }
    
    bool IsValidTouch(int index, float distanceDiff)
    {
        // å‘¨å›²ã®ç‚¹ã‚‚åŒæ§˜ã®å¤‰åŒ–ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        int validNeighbors = 0;
        int checkRange = 2;
        
        for (int offset = -checkRange; offset <= checkRange; offset++)
        {
            int neighborIndex = index + offset;
            if (neighborIndex < 0 || neighborIndex >= filteredDistances.Count || neighborIndex == index)
                continue;
                
            float neighborCurrent = filteredDistances[neighborIndex];
            float neighborBase = baselineDistances[neighborIndex];
            
            if (neighborCurrent > 0 && neighborBase > 0)
            {
                float neighborDiff = neighborBase - neighborCurrent;
                if (neighborDiff > touchThreshold * 0.5f) // åŠåˆ†ã®é–¾å€¤ã§ã‚‚å¤‰åŒ–ãŒã‚ã‚Œã°
                {
                    validNeighbors++;
                }
            }
        }
        
        return validNeighbors >= 1; // æœ€ä½1ã¤ã®éš£æ¥ç‚¹ã§å¤‰åŒ–ãŒã‚ã‚Œã°OK
    }
    
    List<List<int>> ClusterTouchPoints(List<int> candidates)
    {
        var clusters = new List<List<int>>();
        var used = new HashSet<int>();
        
        foreach (int candidate in candidates)
        {
            if (used.Contains(candidate)) continue;
            
            var cluster = new List<int> { candidate };
            used.Add(candidate);
            
            // éš£æ¥ç‚¹ã‚’æ¢ã—ã¦ã‚¯ãƒ©ã‚¹ã‚¿ã«è¿½åŠ 
            for (int i = 0; i < cluster.Count; i++)
            {
                int current = cluster[i];
                
                // å‰å¾Œã®ç‚¹ã‚’ãƒã‚§ãƒƒã‚¯
                for (int offset = -1; offset <= 1; offset += 2)
                {
                    int neighbor = current + offset;
                    if (candidates.Contains(neighbor) && !used.Contains(neighbor))
                    {
                        cluster.Add(neighbor);
                        used.Add(neighbor);
                    }
                }
            }
            
            clusters.Add(cluster);
        }
        
        return clusters;
    }
    
    bool CheckTouchConsistency(List<int> cluster)
    {
        // ã‚¯ãƒ©ã‚¹ã‚¿å†…ã®ç‚¹ãŒè¤‡æ•°ãƒ•ãƒ¬ãƒ¼ãƒ ã§æ¤œå‡ºã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        int consistentPoints = 0;
        
        foreach (int index in cluster)
        {
            // ãƒ•ãƒ¬ãƒ¼ãƒ å±¥æ­´ã‚’æ›´æ–°
            for (int frame = consistentFramesRequired - 1; frame > 0; frame--)
            {
                consistentTouchFrames[index, frame] = consistentTouchFrames[index, frame - 1];
            }
            consistentTouchFrames[index, 0] = 1; // ç¾åœ¨ãƒ•ãƒ¬ãƒ¼ãƒ ã§æ¤œå‡º
            
            // å¿…è¦ãƒ•ãƒ¬ãƒ¼ãƒ æ•°é€£ç¶šã§æ¤œå‡ºã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            int consecutiveFrames = 0;
            for (int frame = 0; frame < consistentFramesRequired; frame++)
            {
                if (consistentTouchFrames[index, frame] == 1)
                    consecutiveFrames++;
                else
                    break;
            }
            
            if (consecutiveFrames >= consistentFramesRequired)
            {
                consistentPoints++;
            }
        }
        
        return consistentPoints >= Mathf.Max(1, cluster.Count / 2); // åŠåˆ†ä»¥ä¸Šã®ç‚¹ãŒä¸€è²«ã—ã¦ã„ã‚‹
    }
    
    TouchInfo CreateTouchInfo(List<int> cluster)
    {
        // ã‚¯ãƒ©ã‚¹ã‚¿ã®ä¸­å¿ƒä½ç½®ã‚’è¨ˆç®—
        Vector3 centerPosition = Vector3.zero;
        float totalIntensity = 0f;
        
        foreach (int index in cluster)
        {
            Vector3 pos = CalculateWorldPosition(index, filteredDistances[index]);
            float intensity = baselineDistances[index] - filteredDistances[index];
            
            centerPosition += pos * intensity;
            totalIntensity += intensity;
        }
        
        if (totalIntensity > 0)
        {
            centerPosition /= totalIntensity;
        }
        
        return new TouchInfo(centerPosition, totalIntensity, cluster.Min(), cluster.Max());
    }
    
    void ProcessValidTouches(List<TouchInfo> detectedTouches)
    {
        float currentTime = Time.time;
        
        foreach (var touch in detectedTouches)
        {
            // æ—¢å­˜ã®ã‚¿ãƒƒãƒã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
            bool isNewTouch = true;
            
            foreach (var existingTouch in activeTouches.Values)
            {
                float distance = Vector3.Distance(touch.position, existingTouch.position);
                if (distance < 2f) // 2mä»¥å†…ã¯åŒã˜ã‚¿ãƒƒãƒã¨ã¿ãªã™
                {
                    isNewTouch = false;
                    break;
                }
            }
            
            if (isNewTouch)
            {
                // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯
                bool canTrigger = true;
                foreach (var kvp in lastTouchTime)
                {
                    if (currentTime - kvp.Value < touchCooldown)
                    {
                        canTrigger = false;
                        break;
                    }
                }
                
                if (canTrigger)
                {
                    OnWallTouched(touch);
                    lastTouchTime[touch.startIndex] = currentTime;
                }
            }
        }
        
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ãƒƒãƒã®æ›´æ–°
        activeTouches.Clear();
        for (int i = 0; i < detectedTouches.Count; i++)
        {
            activeTouches[i] = detectedTouches[i];
        }
    }
    
    Vector3 CalculateWorldPosition(int index, float distance)
    {
        float angleRange = 270f; // UST-20LXã®æ¸¬å®šç¯„å›²
        float angleStep = angleRange / (filteredDistances.Count - 1);
        float startAngle = -135f; // ä¸­å¤®ã‚’0åº¦ã¨ã—ãŸå ´åˆã®é–‹å§‹è§’åº¦
        
        float angle = (startAngle + angleStep * index) * Mathf.Deg2Rad;
        float x = distance * Mathf.Cos(angle) * visualScale;
        float z = distance * Mathf.Sin(angle) * visualScale;
        
        return new Vector3(x, 0, z);
    }
    
    void OnWallTouched(TouchInfo touchInfo)
    {
        totalDetections++;
        validDetections++;
        
        Debug.Log($"âœ¨ ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡º #{validDetections}");
        Debug.Log($"   ä½ç½®: ({touchInfo.position.x:F2}, {touchInfo.position.z:F2})");
        Debug.Log($"   å¼·åº¦: {touchInfo.intensity:F1}mm");
        Debug.Log($"   ç¯„å›²: ç‚¹{touchInfo.startIndex}-{touchInfo.endIndex}");
        
        if (showTouchVisualization)
        {
            CreateTouchEffect(touchInfo);
        }
        
        // ğŸ† èŠ±ç«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç™ºå‹•ï¼ˆã“ã®éƒ¨åˆ†ã ã‘æ–°è¦è¿½åŠ ï¼‰
        SpawnFireworks(touchInfo);
    }
    
    // ========== ğŸ† èŠ±ç«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–¢é€£ï¼ˆã™ã¹ã¦æ–°è¦è¿½åŠ ï¼‰==========
    
    void SpawnFireworks(TouchInfo touchInfo)
    {
        // èŠ±ç«ã®ç”Ÿæˆä½ç½®ï¼ˆã‚¿ãƒƒãƒä½ç½® + é«˜ã•ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
        Vector3 spawnPosition = touchInfo.position + Vector3.up * fireworksHeightOffset;
        
        GameObject fireworks;
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ¬ãƒãƒ–ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨
        if (fireworksPrefab != null)
        {
            fireworks = Instantiate(fireworksPrefab, spawnPosition, Quaternion.identity);
            fireworks.name = $"Fireworks_{validDetections}";
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®è¨­å®š
            ParticleSystem ps = fireworks.GetComponent<ParticleSystem>();
            if (ps != null)
            {
                var main = ps.main;
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²
                Color fireworkColor = fireworksColors[UnityEngine.Random.Range(0, fireworksColors.Length)];
                main.startColor = fireworkColor;
                
                ps.Play();
            }
        }
        else
        {
            // ãƒ—ãƒ¬ãƒãƒ–ãŒãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®çƒä½“ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            fireworks = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            fireworks.transform.position = spawnPosition;
            fireworks.name = "Default_Fireworks";
            
            // ã‚µã‚¤ã‚ºã¨è‰²è¨­å®š
            fireworks.transform.localScale = Vector3.one * fireworksScale;
            
            Renderer renderer = fireworks.GetComponent<Renderer>();
            Material mat = new Material(Shader.Find("Sprites/Default"));
            Color fireworkColor = fireworksColors[UnityEngine.Random.Range(0, fireworksColors.Length)];
            mat.color = fireworkColor;
            renderer.material = mat;
            
            // ç°¡æ˜“ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            StartCoroutine(AnimateDefaultFireworks(fireworks, fireworkColor));
        }
        
        activeFireworks.Add(fireworks);
        Destroy(fireworks, fireworksDuration);
        
        // éŸ³éŸ¿ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        if (audioSource != null && fireworksSound != null)
        {
            audioSource.PlayOneShot(fireworksSound);
        }
        
        Debug.Log($"ğŸ† èŠ±ç«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”Ÿæˆ: {spawnPosition}");
    }
    
    System.Collections.IEnumerator AnimateDefaultFireworks(GameObject fireworks, Color color)
    {
        float elapsed = 0f;
        Vector3 initialScale = fireworks.transform.localScale;
        Renderer renderer = fireworks.GetComponent<Renderer>();
        
        while (elapsed < fireworksDuration && fireworks != null)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / fireworksDuration;
            
            // ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ‹¡å¤§â†’ç¸®å°ï¼‰
            float scale = Mathf.Sin(t * Mathf.PI);
            fireworks.transform.localScale = initialScale * (0.5f + scale);
            
            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
            Color currentColor = color;
            currentColor.a = 1f - t;
            renderer.material.color = currentColor;
            
            yield return null;
        }
    }
    
    // =================================================
    
    void CreateTouchEffect(TouchInfo touchInfo)
    {
        GameObject effect = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        effect.transform.position = touchInfo.position;
        
        // å¼·åº¦ã«åŸºã¥ã„ã¦ã‚µã‚¤ã‚ºã‚’èª¿æ•´
        float size = Mathf.Clamp(touchInfo.intensity / 20f, 0.5f, 3f);
        effect.transform.localScale = Vector3.one * size;
        effect.name = "Touch Effect";
        
        Renderer renderer = effect.GetComponent<Renderer>();
        renderer.material = new Material(Shader.Find("Sprites/Default"));
        renderer.material.color = touchIndicatorColor;
        
        touchEffects.Add(effect);
        
        // 3ç§’å¾Œã«å‰Šé™¤
        Destroy(effect, 3f);
    }
    
    void CleanupOldEffects()
    {
        touchEffects.RemoveAll(effect => effect == null);
        activeFireworks.RemoveAll(firework => firework == null); // ğŸ† æ–°è¦è¿½åŠ 
    }
    
    void VisualizeScanning()
    {
        if (filteredDistances.Count == 0) return;
        
        scanLineRenderer.positionCount = filteredDistances.Count + 1;
        
        for (int i = 0; i < filteredDistances.Count; i++)
        {
            Vector3 position = CalculateWorldPosition(i, filteredDistances[i]);
            scanLineRenderer.SetPosition(i, position);
        }
        
        // æœ€åˆã®ç‚¹ã«æˆ»ã£ã¦ç·šã‚’é–‰ã˜ã‚‹
        scanLineRenderer.SetPosition(filteredDistances.Count, scanLineRenderer.GetPosition(0));
    }
    
    void ShowDebugInfo()
    {
        if (!isCalibrated || filteredDistances.Count == 0) return;
        
        float avgDiff = 0f;
        int validDiffs = 0;
        
        for (int i = 0; i < filteredDistances.Count; i++)
        {
            if (i >= baselineDistances.Count) break;
            
            float current = filteredDistances[i];
            float baseline = baselineDistances[i];
            
            if (current > 0 && baseline > 0)
            {
                avgDiff += Mathf.Abs(baseline - current);
                validDiffs++;
            }
        }
        
        if (validDiffs > 0) avgDiff /= validDiffs;
        
        float detectionRate = totalDetections > 0 ? (float)validDetections / totalDetections * 100f : 0f;
        
        Debug.Log($"[ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°] å¹³å‡å¤‰åŒ–: {avgDiff:F1}mm | æœ‰åŠ¹æ¤œå‡ºç‡: {detectionRate:F1}% | ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ãƒƒãƒ: {activeTouches.Count} | èŠ±ç«: {activeFireworks.Count}"); // ğŸ† èŠ±ç«æ•°ã‚’è¿½åŠ 
    }
    
    // ãƒ‡ãƒ¼ã‚¿å—ä¿¡ã‚¹ãƒ¬ãƒƒãƒ‰
    void ReceiveDataThread()
    {
        byte[] buffer = new byte[8192];
        StringBuilder messageBuilder = new StringBuilder();
        
        while (isRunning)
        {
            try
            {
                if (stream != null && stream.DataAvailable)
                {
                    int bytesRead = stream.Read(buffer, 0, buffer.Length);
                    string chunk = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    messageBuilder.Append(chunk);
                    
                    ProcessMessageBuffer(messageBuilder);
                }
                Thread.Sleep(1);
            }
            catch (Exception e)
            {
                if (isRunning) Debug.LogError($"ãƒ‡ãƒ¼ã‚¿å—ä¿¡ã‚¨ãƒ©ãƒ¼: {e.Message}");
            }
        }
    }
    
    void ProcessMessageBuffer(StringBuilder messageBuilder)
    {
        string fullMessage = messageBuilder.ToString();
        string[] lines = fullMessage.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
        
        if (!fullMessage.EndsWith("\n"))
        {
            messageBuilder.Clear();
            messageBuilder.Append(lines[lines.Length - 1]);
            Array.Resize(ref lines, lines.Length - 1);
        }
        else
        {
            messageBuilder.Clear();
        }
        
        foreach (string line in lines)
        {
            if (!string.IsNullOrWhiteSpace(line))
            {
                lock (queueLock)
                {
                    dataQueue.Enqueue(line.Trim());
                }
            }
        }
    }
    
    void ProcessReceivedData()
    {
        lock (queueLock)
        {
            while (dataQueue.Count > 0)
            {
                ParseLiDARData(dataQueue.Dequeue());
            }
        }
    }
    
    void ParseLiDARData(string line)
    {
        // ã‚³ãƒãƒ³ãƒ‰å¿œç­”ã‚„ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
        if (line.StartsWith("MD") || line.Length <= 5 || 
            (line.Length < 20 && char.IsUpper(line[0]))) return;
        
        // è·é›¢ãƒ‡ãƒ¼ã‚¿ã®ã¿å‡¦ç†
        if (line.Length > 50)
        {
            var distances = DecodeSCIP2Data(line);
            if (distances.Count > 0)
            {
                lock (queueLock)
                {
                    currentDistances = distances;
                }
            }
        }
    }
    
    List<float> DecodeSCIP2Data(string encodedData)
    {
        var distances = new List<float>();
        
        for (int i = 0; i <= encodedData.Length - 3; i += 3)
        {
            try
            {
                int val = ((encodedData[i] - 0x30) << 12) | 
                          ((encodedData[i + 1] - 0x30) << 6) | 
                          (encodedData[i + 2] - 0x30);
                
                distances.Add(val);
            }
            catch
            {
                break;
            }
        }
        
        return distances;
    }
    
    void SendCommand(string command)
    {
        try
        {
            byte[] data = Encoding.ASCII.GetBytes(command);
            stream.Write(data, 0, data.Length);
            stream.Flush();
        }
        catch (Exception e)
        {
            Debug.LogError($"ã‚³ãƒãƒ³ãƒ‰é€ä¿¡ã‚¨ãƒ©ãƒ¼: {e.Message}");
        }
    }
    
    void OnApplicationQuit()
    {
        isRunning = false;
        
        if (receiveThread != null && receiveThread.IsAlive)
            receiveThread.Join(1000);
        
        if (stream != null)
        {
            try
            {
                SendCommand("QT\n");
                Thread.Sleep(100);
                stream.Close();
            }
            catch { }
        }
        
        if (client != null)
        {
            try { client.Close(); }
            catch { }
        }
    }
    
    // ãƒ‘ãƒ–ãƒªãƒƒã‚¯ ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¤–éƒ¨ã‹ã‚‰ã®åˆ¶å¾¡ç”¨ï¼‰
    public void ManualCalibration()
    {
        PerformCalibration();
    }
    
    public void SetTouchThreshold(float threshold)
    {
        touchThreshold = threshold;
        Debug.Log($"ã‚¿ãƒƒãƒé–¾å€¤ã‚’{threshold}mmã«è¨­å®š");
    }
    
    public bool IsSystemReady()
    {
        return isCalibrated && currentDistances.Count > 0;
    }
    
    public void EnableDebugMode(bool enable)
    {
        showDebugInfo = enable;
        showTouchVisualization = enable;
    }
}
