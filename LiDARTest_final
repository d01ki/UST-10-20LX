using System;
using System.Net.Sockets;
using System.Text;
using UnityEngine;
using System.Threading;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// ğŸ† ã‚·ãƒ³ãƒ—ãƒ«èŠ±ç«ã‚·ã‚¹ãƒ†ãƒ  - ã‚¢ã‚»ãƒƒãƒˆã®ã¿ + å¤œç©ºèƒŒæ™¯
/// </summary>
public class LiDARTest : MonoBehaviour
{
    [Header("LiDAR Connection")]
    public string lidarIP = "192.168.0.10";
    public int lidarPort = 10940;
    
    [Header("Touch Detection")]
    public float touchThreshold = 30f;
    public int consistentFramesRequired = 3;
    public int minTouchAreaSize = 2;
    public float touchCooldown = 0.2f;
    
    [Header("Spatial Filtering")]
    public int spatialFilterWindow = 3;
    public float temporalFilterAlpha = 0.7f;
    
    [Header("Visualization")]
    public float visualScale = 0.01f;
    public float maxDistance = 5000f;
    
    // ========== ğŸŒŸ ç·‘ã®ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ã®è¡¨ç¤ºè¨­å®š ==========
    [Header("ğŸŒŸ Scan Line Settings")]
    [Tooltip("ç·‘ã®ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹ã‹ï¼ˆéè¡¨ç¤ºã«ã™ã‚‹å ´åˆã¯âŒï¼‰")]
    public bool showScanLine = false;  // â† ã“ã“ã‚’ false ã«ã™ã‚‹ã¨ç·‘ã®ãƒªãƒ³ã‚°ãŒæ¶ˆãˆã‚‹
    
    public Color scanLineColor = Color.green;
    public float lineWidth = 0.05f;
    // ==================================================
    
    [Header("Camera Setup")]
    public bool autoSetupCamera = false;
    public float cameraHeight = 50f;
    public float cameraSize = 25f;
    
    // ========== ğŸŒŒ å¤œç©ºã®èƒŒæ™¯è¨­å®š ==========
    [Header("ğŸŒŒ Night Sky Background")]
    [Tooltip("å¤œç©ºã®èƒŒæ™¯è‰²ï¼ˆçœŸã£é»’ï¼‰")]
    public Color skyColor = Color.black;  // â† è‰²ã‚’å¤‰ãˆãŸã„å ´åˆã¯ã“ã“ã‚’å¤‰æ›´
    
    [Tooltip("æ˜Ÿã‚’è¡¨ç¤ºã™ã‚‹ã‹")]
    public bool showStars = true;  // â† æ˜Ÿã‚’æ¶ˆã—ãŸã„å ´åˆã¯ false ã«
    
    [Tooltip("æ˜Ÿã®æ•°")]
    [Range(0, 500)]
    public int starCount = 200;  // â† æ˜Ÿã®æ•°ã‚’å¤‰æ›´
    
    [Tooltip("æ˜Ÿã®ã‚µã‚¤ã‚º")]
    [Range(0.01f, 0.3f)]
    public float starSize = 0.1f;  // â† æ˜Ÿã®ã‚µã‚¤ã‚ºã‚’å¤‰æ›´
    
    [Tooltip("æ˜Ÿã®æ˜ã‚‹ã•")]
    [Range(0.1f, 1f)]
    public float starBrightness = 0.8f;  // â† æ˜Ÿã®æ˜ã‚‹ã•ã‚’å¤‰æ›´
    // ======================================
    
    [Header("Debug")]
    public bool showDebugInfo = true;
    
    // ========== ğŸ† èŠ±ç«ã‚¢ã‚»ãƒƒãƒˆè¨­å®š ==========
    [Header("ğŸ† Fireworks Asset")]
    [Tooltip("èŠ±ç«ãƒ—ãƒ¬ãƒãƒ–ã®é…åˆ—ï¼ˆã‚¢ã‚»ãƒƒãƒˆï¼‰")]
    public GameObject[] fireworksPrefabs;
    
    [Tooltip("èŠ±ç«ã®ã‚µã‚¤ã‚º")]
    [Range(0.1f, 5f)]
    public float fireworksScale = 1.5f;
    
    [Tooltip("èŠ±ç«ã®æŒç¶šæ™‚é–“")]
    [Range(1f, 10f)]
    public float fireworksDuration = 5f;
    
    [Tooltip("èŠ±ç«ã®é«˜ã•ã‚ªãƒ•ã‚»ãƒƒãƒˆ")]
    [Range(0f, 10f)]
    public float fireworksHeightOffset = 3f;
    
    [Tooltip("åŒæ™‚ã«è¡¨ç¤ºã§ãã‚‹æœ€å¤§èŠ±ç«æ•°")]
    [Range(1, 20)]
    public int maxSimultaneousFireworks = 10;
    
    [Tooltip("ã‚¿ãƒƒãƒã®å¼·åº¦ã§ã‚µã‚¤ã‚ºãŒå¤‰åŒ–")]
    public bool intensityAffectsScale = true;
    
    [Tooltip("åŠ¹æœéŸ³")]
    public AudioClip[] fireworksSounds;
    
    [Tooltip("åŠ¹æœéŸ³ã®ãƒœãƒªãƒ¥ãƒ¼ãƒ ")]
    [Range(0f, 1f)]
    public float soundVolume = 0.8f;
    // =======================================
    
    // é€šä¿¡é–¢é€£
    private TcpClient client;
    private NetworkStream stream;
    private Thread receiveThread;
    private bool isRunning = false;
    
    // ãƒ‡ãƒ¼ã‚¿ç®¡ç†
    private Queue<string> dataQueue = new Queue<string>();
    private object queueLock = new object();
    
    // è·é›¢ãƒ‡ãƒ¼ã‚¿
    private List<float> currentDistances = new List<float>();
    private List<float> baselineDistances = new List<float>();
    private List<float> filteredDistances = new List<float>();
    private List<float> previousDistances = new List<float>();
    
    // ã‚¿ãƒƒãƒæ¤œå‡º
    private int[,] consistentTouchFrames;
    private Dictionary<int, TouchInfo> activeTouches = new Dictionary<int, TouchInfo>();
    private Dictionary<int, float> lastTouchTime = new Dictionary<int, float>();
    private bool isCalibrated = false;
    
    // å¯è¦–åŒ–
    private LineRenderer scanLineRenderer;
    private GameObject sensorPosition;
    private List<GameObject> activeFireworks = new List<GameObject>();
    private AudioSource audioSource;
    
    // å¤œç©ºã®æ˜Ÿ
    private List<GameObject> stars = new List<GameObject>();
    
    // çµ±è¨ˆ
    private int validDetections = 0;
    private float lastDebugTime = 0f;
    
    [System.Serializable]
    public class TouchInfo
    {
        public Vector3 position;
        public float intensity;
        public int startIndex;
        public int endIndex;
        public float timestamp;
        
        public TouchInfo(Vector3 pos, float intens, int start, int end)
        {
            position = pos;
            intensity = intens;
            startIndex = start;
            endIndex = end;
            timestamp = Time.time;
        }
    }
    
    void Start()
    {
        Debug.Log("=== ğŸ† ã‚·ãƒ³ãƒ—ãƒ«èŠ±ç«ã‚·ã‚¹ãƒ†ãƒ  + å¤œç©ºèƒŒæ™¯ ===");
        
        SetupCamera();
        SetupVisualization();
        CreateNightSky();  // å¤œç©ºã‚’ä½œæˆ
        SetupAudio();
        ConnectToLiDAR();
        
        Invoke(nameof(PerformCalibration), 3f);
        
        if (fireworksPrefabs != null && fireworksPrefabs.Length > 0)
        {
            Debug.Log($"âœ… {fireworksPrefabs.Length}å€‹ã®èŠ±ç«ãƒ—ãƒ¬ãƒãƒ–ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ");
        }
    }
    
    void SetupAudio()
    {
        audioSource = gameObject.AddComponent<AudioSource>();
        audioSource.playOnAwake = false;
        audioSource.spatialBlend = 0f;
        audioSource.volume = soundVolume;
    }
    
    void SetupCamera()
    {
        if (!autoSetupCamera) return;
        
        Camera mainCamera = Camera.main;
        if (mainCamera == null) return;
        
        mainCamera.transform.position = new Vector3(0, cameraHeight, 0);
        mainCamera.transform.rotation = Quaternion.Euler(90f, 0, 0);
        mainCamera.orthographic = true;
        mainCamera.orthographicSize = cameraSize;
        
        // ========== å¤œç©ºã®èƒŒæ™¯è‰²ã‚’è¨­å®š ==========
        mainCamera.backgroundColor = skyColor;  // çœŸã£é»’ãªå¤œç©º
        // =======================================
    }
    
    void SetupVisualization()
    {
        // ========== ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ï¼ˆç·‘ã®ãƒªãƒ³ã‚°ï¼‰==========
        scanLineRenderer = gameObject.AddComponent<LineRenderer>();
        scanLineRenderer.material = new Material(Shader.Find("Sprites/Default"));
        scanLineRenderer.startColor = scanLineColor;
        scanLineRenderer.endColor = scanLineColor;
        scanLineRenderer.startWidth = lineWidth;
        scanLineRenderer.endWidth = lineWidth;
        scanLineRenderer.useWorldSpace = true;
        
        // ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ã®è¡¨ç¤º/éè¡¨ç¤º
        scanLineRenderer.enabled = showScanLine;  // â† ã“ã“ã§è¡¨ç¤ºåˆ¶å¾¡
        // ==============================================
        
        // ã‚»ãƒ³ã‚µãƒ¼ä½ç½®ï¼ˆé»„è‰²ã„çƒï¼‰
        sensorPosition = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        sensorPosition.transform.position = Vector3.zero;
        sensorPosition.transform.localScale = Vector3.one * 0.5f;
        sensorPosition.name = "LiDAR Sensor";
        
        Renderer renderer = sensorPosition.GetComponent<Renderer>();
        renderer.material = new Material(Shader.Find("Sprites/Default"));
        renderer.material.color = Color.yellow;
    }
    
    // ========== ğŸŒŒ å¤œç©ºã®ä½œæˆ ==========
    void CreateNightSky()
    {
        if (!showStars) return;  // æ˜Ÿã‚’è¡¨ç¤ºã—ãªã„å ´åˆã¯çµ‚äº†
        
        // ãƒ©ãƒ³ãƒ€ãƒ ã«æ˜Ÿã‚’é…ç½®
        for (int i = 0; i < starCount; i++)
        {
            GameObject star = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            star.name = $"Star_{i}";
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®
            float x = UnityEngine.Random.Range(-cameraSize, cameraSize);
            float z = UnityEngine.Random.Range(-cameraSize, cameraSize);
            star.transform.position = new Vector3(x, 0.1f, z);  // å°‘ã—æµ®ã‹ã›ã‚‹
            
            // ã‚µã‚¤ã‚º
            float size = starSize * UnityEngine.Random.Range(0.5f, 1.5f);
            star.transform.localScale = Vector3.one * size;
            
            // ç™½è‰²ã§è¼ã
            Renderer renderer = star.GetComponent<Renderer>();
            Material mat = new Material(Shader.Find("Sprites/Default"));
            Color starColor = Color.white * starBrightness;
            starColor.a = UnityEngine.Random.Range(0.6f, 1f);  // æ˜ã‚‹ã•ã«ãƒ©ãƒ³ãƒ€ãƒ æ€§
            mat.color = starColor;
            renderer.material = mat;
            
            // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼å‰Šé™¤ï¼ˆè»½é‡åŒ–ï¼‰
            Destroy(star.GetComponent<Collider>());
            
            stars.Add(star);
            
            // ã‚­ãƒ©ã‚­ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            StartCoroutine(TwinkleStar(star, renderer));
        }
        
        Debug.Log($"ğŸŒŸ {starCount}å€‹ã®æ˜Ÿã‚’ä½œæˆã—ã¾ã—ãŸ");
    }
    
    // æ˜Ÿã®ã‚­ãƒ©ã‚­ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    System.Collections.IEnumerator TwinkleStar(GameObject star, Renderer renderer)
    {
        float baseAlpha = UnityEngine.Random.Range(0.6f, 1f);
        float twinkleSpeed = UnityEngine.Random.Range(0.5f, 2f);
        
        while (star != null)
        {
            float t = Mathf.PingPong(Time.time * twinkleSpeed, 1f);
            Color color = renderer.material.color;
            color.a = Mathf.Lerp(baseAlpha * 0.3f, baseAlpha, t);
            renderer.material.color = color;
            
            yield return null;
        }
    }
    // ==================================
    
    void ConnectToLiDAR()
    {
        try
        {
            Debug.Log($"LiDARã«æ¥ç¶šä¸­: {lidarIP}:{lidarPort}");
            
            client = new TcpClient();
            client.Connect(lidarIP, lidarPort);
            stream = client.GetStream();
            stream.ReadTimeout = 5000;
            stream.WriteTimeout = 5000;
            
            SendCommand("SCIP2.0\n");
            Thread.Sleep(200);
            SendCommand("BM\n");
            Thread.Sleep(200);
            SendCommand("MD0000072500000\n");
            Thread.Sleep(200);
            
            isRunning = true;
            receiveThread = new Thread(ReceiveDataThread);
            receiveThread.IsBackground = true;
            receiveThread.Start();
            
            Debug.Log("LiDARæ¥ç¶šå®Œäº†");
        }
        catch (Exception e)
        {
            Debug.LogError($"LiDARæ¥ç¶šã‚¨ãƒ©ãƒ¼: {e.Message}");
        }
    }
    
    void PerformCalibration()
    {
        lock (queueLock)
        {
            if (currentDistances.Count == 0)
            {
                Debug.LogWarning("ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™");
                Invoke(nameof(PerformCalibration), 2f);
                return;
            }
            
            baselineDistances = new List<float>(ApplySpatialFilter(currentDistances));
            filteredDistances = new List<float>(baselineDistances);
            previousDistances = new List<float>(baselineDistances);
            consistentTouchFrames = new int[baselineDistances.Count, consistentFramesRequired];
            
            isCalibrated = true;
            
            var validDistances = baselineDistances.Where(d => d > 0 && d < maxDistance).ToList();
            if (validDistances.Any())
            {
                Debug.Log("========== ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº† ==========");
                Debug.Log($"æ¸¬å®šç‚¹æ•°: {baselineDistances.Count}");
                Debug.Log($"æœ‰åŠ¹æ¸¬å®šç‚¹: {validDistances.Count}");
                Debug.Log($"æ¤œå‡ºé–¾å€¤: {touchThreshold}mm");
                Debug.Log("=========================================");
            }
        }
    }
    
    void Update()
    {
        ProcessReceivedData();
        
        if (currentDistances.Count > 0)
        {
            ApplyFiltering();
            
            // ========== ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³è¡¨ç¤ºã®åˆ¶å¾¡ ==========
            if (showScanLine)
            {
                VisualizeScanning();  // ç·‘ã®ãƒªãƒ³ã‚°ã‚’è¡¨ç¤º
            }
            // ===========================================
            
            if (isCalibrated)
            {
                DetectTouches();
            }
        }
        
        if (showDebugInfo && Time.time - lastDebugTime > 3f)
        {
            ShowDebugInfo();
            lastDebugTime = Time.time;
        }
        
        CleanupOldEffects();
    }
    
    void ApplyFiltering()
    {
        if (currentDistances.Count == 0) return;
        
        var spatialFiltered = ApplySpatialFilter(currentDistances);
        
        if (filteredDistances.Count == spatialFiltered.Count)
        {
            for (int i = 0; i < spatialFiltered.Count; i++)
            {
                filteredDistances[i] = temporalFilterAlpha * filteredDistances[i] + 
                                     (1 - temporalFilterAlpha) * spatialFiltered[i];
            }
        }
        else
        {
            filteredDistances = new List<float>(spatialFiltered);
        }
        
        previousDistances = new List<float>(filteredDistances);
    }
    
    List<float> ApplySpatialFilter(List<float> distances)
    {
        var filtered = new List<float>(distances);
        int halfWindow = spatialFilterWindow / 2;
        
        for (int i = halfWindow; i < distances.Count - halfWindow; i++)
        {
            var windowValues = new List<float>();
            
            for (int j = i - halfWindow; j <= i + halfWindow; j++)
            {
                if (j >= 0 && j < distances.Count && distances[j] > 0)
                {
                    windowValues.Add(distances[j]);
                }
            }
            
            if (windowValues.Count >= 2)
            {
                windowValues.Sort();
                filtered[i] = windowValues[windowValues.Count / 2];
            }
        }
        
        return filtered;
    }
    
    void DetectTouches()
    {
        if (baselineDistances.Count != filteredDistances.Count) return;
        
        var currentTouches = new List<TouchInfo>();
        var touchCandidates = new List<int>();
        
        for (int i = 0; i < filteredDistances.Count; i++)
        {
            float currentDist = filteredDistances[i];
            float baseDist = baselineDistances[i];
            
            if (currentDist <= 0 || baseDist <= 0) continue;
            
            float distanceDiff = baseDist - currentDist;
            
            if (distanceDiff > touchThreshold)
            {
                if (IsValidTouch(i, distanceDiff))
                {
                    touchCandidates.Add(i);
                }
            }
        }
        
        var touchClusters = ClusterTouchPoints(touchCandidates);
        
        foreach (var cluster in touchClusters)
        {
            if (cluster.Count >= minTouchAreaSize)
            {
                bool isConsistent = CheckTouchConsistency(cluster);
                
                if (isConsistent)
                {
                    var touchInfo = CreateTouchInfo(cluster);
                    currentTouches.Add(touchInfo);
                }
            }
        }
        
        ProcessValidTouches(currentTouches);
    }
    
    bool IsValidTouch(int index, float distanceDiff)
    {
        int validNeighbors = 0;
        int checkRange = 2;
        
        for (int offset = -checkRange; offset <= checkRange; offset++)
        {
            int neighborIndex = index + offset;
            if (neighborIndex < 0 || neighborIndex >= filteredDistances.Count || neighborIndex == index)
                continue;
                
            float neighborCurrent = filteredDistances[neighborIndex];
            float neighborBase = baselineDistances[neighborIndex];
            
            if (neighborCurrent > 0 && neighborBase > 0)
            {
                float neighborDiff = neighborBase - neighborCurrent;
                if (neighborDiff > touchThreshold * 0.5f)
                {
                    validNeighbors++;
                }
            }
        }
        
        return validNeighbors >= 1;
    }
    
    List<List<int>> ClusterTouchPoints(List<int> candidates)
    {
        var clusters = new List<List<int>>();
        var used = new HashSet<int>();
        
        foreach (int candidate in candidates)
        {
            if (used.Contains(candidate)) continue;
            
            var cluster = new List<int> { candidate };
            used.Add(candidate);
            
            for (int i = 0; i < cluster.Count; i++)
            {
                int current = cluster[i];
                
                for (int offset = -1; offset <= 1; offset += 2)
                {
                    int neighbor = current + offset;
                    if (candidates.Contains(neighbor) && !used.Contains(neighbor))
                    {
                        cluster.Add(neighbor);
                        used.Add(neighbor);
                    }
                }
            }
            
            clusters.Add(cluster);
        }
        
        return clusters;
    }
    
    bool CheckTouchConsistency(List<int> cluster)
    {
        int consistentPoints = 0;
        
        foreach (int index in cluster)
        {
            for (int frame = consistentFramesRequired - 1; frame > 0; frame--)
            {
                consistentTouchFrames[index, frame] = consistentTouchFrames[index, frame - 1];
            }
            consistentTouchFrames[index, 0] = 1;
            
            int consecutiveFrames = 0;
            for (int frame = 0; frame < consistentFramesRequired; frame++)
            {
                if (consistentTouchFrames[index, frame] == 1)
                    consecutiveFrames++;
                else
                    break;
            }
            
            if (consecutiveFrames >= consistentFramesRequired)
            {
                consistentPoints++;
            }
        }
        
        return consistentPoints >= Mathf.Max(1, cluster.Count / 2);
    }
    
    TouchInfo CreateTouchInfo(List<int> cluster)
    {
        Vector3 centerPosition = Vector3.zero;
        float totalIntensity = 0f;
        
        foreach (int index in cluster)
        {
            Vector3 pos = CalculateWorldPosition(index, filteredDistances[index]);
            float intensity = baselineDistances[index] - filteredDistances[index];
            
            centerPosition += pos * intensity;
            totalIntensity += intensity;
        }
        
        if (totalIntensity > 0)
        {
            centerPosition /= totalIntensity;
        }
        
        return new TouchInfo(centerPosition, totalIntensity, cluster.Min(), cluster.Max());
    }
    
    void ProcessValidTouches(List<TouchInfo> detectedTouches)
    {
        float currentTime = Time.time;
        
        foreach (var touch in detectedTouches)
        {
            bool isNewTouch = true;
            
            foreach (var existingTouch in activeTouches.Values)
            {
                float distance = Vector3.Distance(touch.position, existingTouch.position);
                if (distance < 2f)
                {
                    isNewTouch = false;
                    break;
                }
            }
            
            if (isNewTouch)
            {
                bool canTrigger = true;
                foreach (var kvp in lastTouchTime)
                {
                    if (currentTime - kvp.Value < touchCooldown)
                    {
                        canTrigger = false;
                        break;
                    }
                }
                
                if (canTrigger)
                {
                    OnWallTouched(touch);
                    lastTouchTime[touch.startIndex] = currentTime;
                }
            }
        }
        
        activeTouches.Clear();
        for (int i = 0; i < detectedTouches.Count; i++)
        {
            activeTouches[i] = detectedTouches[i];
        }
    }
    
    Vector3 CalculateWorldPosition(int index, float distance)
    {
        float angleRange = 270f;
        float angleStep = angleRange / (filteredDistances.Count - 1);
        float startAngle = -135f;
        
        float angle = (startAngle + angleStep * index) * Mathf.Deg2Rad;
        float x = distance * Mathf.Cos(angle) * visualScale;
        float z = distance * Mathf.Sin(angle) * visualScale;
        
        return new Vector3(x, 0, z);
    }
    
    void OnWallTouched(TouchInfo touchInfo)
    {
        validDetections++;
        
        Debug.Log($"ğŸ† ã‚¿ãƒƒãƒæ¤œå‡º #{validDetections}");
        
        // èŠ±ç«ã‚¢ã‚»ãƒƒãƒˆã®ã¿ã‚’ç™ºå‹•
        SpawnFireworksOnly(touchInfo);
    }
    
    // ========== ğŸ† èŠ±ç«ã‚¢ã‚»ãƒƒãƒˆã®ã¿ç™ºå‹• ==========
    void SpawnFireworksOnly(TouchInfo touchInfo)
    {
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ¶é™
        if (activeFireworks.Count >= maxSimultaneousFireworks)
        {
            Destroy(activeFireworks[0]);
            activeFireworks.RemoveAt(0);
        }
        
        Vector3 spawnPosition = touchInfo.position + Vector3.up * fireworksHeightOffset;
        
        if (fireworksPrefabs != null && fireworksPrefabs.Length > 0)
        {
            // ãƒ©ãƒ³ãƒ€ãƒ ã«èŠ±ç«ã‚’é¸æŠ
            GameObject selectedPrefab = fireworksPrefabs[UnityEngine.Random.Range(0, fireworksPrefabs.Length)];
            GameObject fireworks = Instantiate(selectedPrefab, spawnPosition, Quaternion.identity);
            fireworks.name = $"Firework_{validDetections}";
            
            // ã‚µã‚¤ã‚ºèª¿æ•´
            float scale = fireworksScale;
            if (intensityAffectsScale)
            {
                float intensityFactor = Mathf.Clamp(touchInfo.intensity / 100f, 0.5f, 2f);
                scale *= intensityFactor;
            }
            fireworks.transform.localScale = Vector3.one * scale;
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å†ç”Ÿ
            ParticleSystem[] particleSystems = fireworks.GetComponentsInChildren<ParticleSystem>();
            foreach (var ps in particleSystems)
            {
                ps.Play();
            }
            
            activeFireworks.Add(fireworks);
            Destroy(fireworks, fireworksDuration);
            
            Debug.Log($"ğŸ† èŠ±ç«ç™ºå°„: {selectedPrefab.name}");
        }
        else
        {
            Debug.LogWarning("âš  èŠ±ç«ãƒ—ãƒ¬ãƒãƒ–ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");
        }
        
        // åŠ¹æœéŸ³
        PlayFireworkSound();
    }
    
    void PlayFireworkSound()
    {
        if (audioSource != null && fireworksSounds != null && fireworksSounds.Length > 0)
        {
            AudioClip selectedSound = fireworksSounds[UnityEngine.Random.Range(0, fireworksSounds.Length)];
            audioSource.PlayOneShot(selectedSound, soundVolume);
        }
    }
    // ==========================================
    
    void CleanupOldEffects()
    {
        activeFireworks.RemoveAll(firework => firework == null);
    }
    
    void VisualizeScanning()
    {
        if (filteredDistances.Count == 0) return;
        
        scanLineRenderer.positionCount = filteredDistances.Count;
        
        for (int i = 0; i < filteredDistances.Count; i++)
        {
            Vector3 position = CalculateWorldPosition(i, filteredDistances[i]);
            scanLineRenderer.SetPosition(i, position);
        }
    }
    
    void ShowDebugInfo()
    {
        if (!isCalibrated || filteredDistances.Count == 0) return;
        
        Debug.Log($"[ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°] æœ‰åŠ¹æ¤œå‡º: {validDetections} | ã‚¢ã‚¯ãƒ†ã‚£ãƒ–èŠ±ç«: {activeFireworks.Count} | æ˜Ÿ: {stars.Count}");
    }
    
    void ReceiveDataThread()
    {
        byte[] buffer = new byte[8192];
        StringBuilder messageBuilder = new StringBuilder();
        
        while (isRunning)
        {
            try
            {
                if (stream != null && stream.DataAvailable)
                {
                    int bytesRead = stream.Read(buffer, 0, buffer.Length);
                    string chunk = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    messageBuilder.Append(chunk);
                    
                    ProcessMessageBuffer(messageBuilder);
                }
                Thread.Sleep(1);
            }
            catch (Exception e)
            {
                if (isRunning) Debug.LogError($"ãƒ‡ãƒ¼ã‚¿å—ä¿¡ã‚¨ãƒ©ãƒ¼: {e.Message}");
            }
        }
    }
    
    void ProcessMessageBuffer(StringBuilder messageBuilder)
    {
        string fullMessage = messageBuilder.ToString();
        string[] lines = fullMessage.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
        
        if (!fullMessage.EndsWith("\n"))
        {
            messageBuilder.Clear();
            messageBuilder.Append(lines[lines.Length - 1]);
            Array.Resize(ref lines, lines.Length - 1);
        }
        else
        {
            messageBuilder.Clear();
        }
        
        foreach (string line in lines)
        {
            if (!string.IsNullOrWhiteSpace(line))
            {
                lock (queueLock)
                {
                    dataQueue.Enqueue(line.Trim());
                }
            }
        }
    }
    
    void ProcessReceivedData()
    {
        lock (queueLock)
        {
            while (dataQueue.Count > 0)
            {
                ParseLiDARData(dataQueue.Dequeue());
            }
        }
    }
    
    void ParseLiDARData(string line)
    {
        if (line.StartsWith("MD") || line.Length <= 5 || 
            (line.Length < 20 && char.IsUpper(line[0]))) return;
        
        if (line.Length > 50)
        {
            var distances = DecodeSCIP2Data(line);
            if (distances.Count > 0)
            {
                lock (queueLock)
                {
                    currentDistances = distances;
                }
            }
        }
    }
    
    List<float> DecodeSCIP2Data(string encodedData)
    {
        var distances = new List<float>();
        
        for (int i = 0; i <= encodedData.Length - 3; i += 3)
        {
            try
            {
                int val = ((encodedData[i] - 0x30) << 12) | 
                          ((encodedData[i + 1] - 0x30) << 6) | 
                          (encodedData[i + 2] - 0x30);
                
                distances.Add(val);
            }
            catch
            {
                break;
            }
        }
        
        return distances;
    }
    
    void SendCommand(string command)
    {
        try
        {
            byte[] data = Encoding.ASCII.GetBytes(command);
            stream.Write(data, 0, data.Length);
            stream.Flush();
        }
        catch (Exception e)
        {
            Debug.LogError($"ã‚³ãƒãƒ³ãƒ‰é€ä¿¡ã‚¨ãƒ©ãƒ¼: {e.Message}");
        }
    }
    
    void OnApplicationQuit()
    {
        isRunning = false;
        
        if (receiveThread != null && receiveThread.IsAlive)
            receiveThread.Join(1000);
        
        if (stream != null)
        {
            try
            {
                SendCommand("QT\n");
                Thread.Sleep(100);
                stream.Close();
            }
            catch { }
        }
        
        if (client != null)
        {
            try { client.Close(); }
            catch { }
        }
        
        // æ˜Ÿã‚’å‰Šé™¤
        foreach (var star in stars)
        {
            if (star != null) Destroy(star);
        }
    }
    
    public void ManualCalibration() => PerformCalibration();
    public bool IsSystemReady() => isCalibrated && currentDistances.Count > 0;
}
